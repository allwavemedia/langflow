# Story 1.2: Basic Inquiry Loop

## Status
InProgress

## Story
**As a** user,  
**I want** the agent to ask me questions about my goals instead of waiting for me to provide all the details,  
**so that** I feel guided in the process.

## Acceptance Criteria
1. After I select a category, the agent asks a high-level open-ended question about my objective.
2. The agent can parse my natural language response to identify key concepts.
3. The agent's next response is a clarifying question, not a proposed solution.

## Tasks / Subtasks
- [ ] Task 1: Implement Post-Category Question Logic (AC: 1)
  - [ ] Extend SocraticController to handle inquiry stage after category selection
  - [ ] Create category-specific initial questions for each workflow type
  - [ ] Implement transition from framing to inquiry workflow stage
- [ ] Task 2: Implement Natural Language Parsing (AC: 2)
  - [ ] Create basic keyword extraction from user responses
  - [ ] Identify key concepts and entities in user input
  - [ ] Store extracted concepts in conversation state for context
- [ ] Task 3: Implement Socratic Question Generation (AC: 3)
  - [ ] Create question generation logic based on identified concepts
  - [ ] Ensure questions are clarifying rather than solution-proposing
  - [ ] Implement question variety to avoid repetitive responses
- [ ] Task 4: Unit Testing (AC: 1, 2, 3)
  - [ ] Test category transition triggers appropriate initial question
  - [ ] Test natural language parsing extracts key concepts correctly
  - [ ] Test question generation produces clarifying (not solution) responses
  - [ ] Test state management tracks inquiry stage progression

## Dev Notes

### Previous Story Insights
From Story 1.1 implementation:
- **Architecture Foundation**: SocraticController and StateManager classes established in `src/backend/base/langflow/agent/`
- **State Management**: Conversation state properly tracks workflow stages and category selection
- **Workflow Transitions**: Controller successfully handles stage transitions from FRAMING to INQUIRY
- **Testing Patterns**: Comprehensive unit testing established with direct Python execution validation

### Architecture Context
**System Design**: Based on modular, stateful agent architecture with Controller/Orchestrator managing conversational flow [Source: architecture.md#2-high-level-architecture]

**Socratic Engine Requirements**: Core persona module that takes conversation state and generates next Socratic question, identifying ambiguities and formulating non-leading questions [Source: architecture.md#3.3-socratic-engine]

**Controller Workflow Stages**: Must determine current workflow stage (framing, inquiry, research, generation) and invoke appropriate modules [Source: architecture.md#3.1-controller-orchestrator]

**Technology Stack**: Python-based application logic with prompt-driven LLM calls for question generation [Source: architecture.md#3.3-socratic-engine]

### Data Models
**State Manager Extensions Required**:
- Current inquiry focus area
- Extracted user concepts and keywords
- Question generation history
- Conversation depth tracking

**Conversation State Updates** [Source: architecture.md#3.2-state-manager]:
- Track transition to inquiry stage
- Store parsed concepts from user responses
- Maintain question-answer pairs for context

### API Specifications  
**Socratic Engine Interface**: Prompt-driven LLM call taking conversation history and current state as input to produce clarifying, non-leading questions [Source: architecture.md#3.3-socratic-engine]

**Question Generation Requirements**: Questions must be clarifying rather than solution-proposing, guided toward understanding user intent

### Component Specifications
**Socratic Engine Module**: Must identify ambiguities in user requests and formulate questions that guide user toward clarity [Source: architecture.md#3.3-socratic-engine]

**Controller Extensions**: Handle inquiry stage processing and invoke Socratic Engine for question generation [Source: architecture.md#3.1-controller-orchestrator]

### File Locations
Based on Story 1.1 established patterns:
- Extend existing `src/backend/base/langflow/agent/controller.py`
- Create new `src/backend/base/langflow/agent/socratic_engine.py`
- Update `src/backend/base/langflow/agent/state_manager.py` for inquiry state tracking

### Testing Requirements
Continue established testing patterns from Story 1.1:
- Direct Python execution for rapid validation
- Unit tests for each acceptance criteria
- State management verification
- Conversation flow testing

### Technical Constraints
**Question Generation**: Must be prompt-driven LLM calls with conversation history as input [Source: architecture.md#3.3-socratic-engine]

**Non-Leading Questions**: Questions must guide toward clarity without proposing solutions [Source: architecture.md#3.3-socratic-engine]

**State Integration**: Must integrate with existing StateManager conversation tracking [Source: architecture.md#3.2-state-manager]

### Project Structure Notes
Following established patterns from Story 1.1 - modular agent architecture within langflow backend structure.

## Testing

### Testing Standards
Continue established patterns from Story 1.1:
- Unit testing for controller logic and state management
- Validation of conversation flow transitions
- Question generation quality assessment
- Natural language parsing accuracy verification

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-26 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*Implementation started by James (Dev Agent)*

### Agent Model Used
GitHub Copilot (Claude-3.5-Sonnet) - 2025-08-26

### Debug Log References  
*To be updated during implementation*

### Completion Notes List
- Started implementation of Story 1.2: Basic Inquiry Loop
- Building on Story 1.1 foundation for Socratic questioning capabilities

### File List
*Files will be listed as they are created/modified*

## QA Results
*This section will be populated by QA Agent after story completion*
